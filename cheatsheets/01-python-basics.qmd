---
title: "Python Basics â€” 9 protipÃ³w"
format:
  html:
    code-tools: true
---

## 1) `enumerate` â€” numeruj elementy w pÄ™tli
```{python}
#| classes: thebe
fruits = ["apple", "banana", "cherry"]
for i, f in enumerate(fruits, start=1):
    print(i, f)
```

**Dlaczego warto:** zamiast rÄ™cznie liczyÄ‡ indeksy.

---

## 2) `zip` â€” paruj listy w locie
```{python}
#| classes: thebe
names = ["Ala", "Bartek", "Cezary"]
scores = [84, 92, 78]
for name, score in zip(names, scores):
    print(f"{name}: {score}")
```

**Protip:** `list(zip(names, scores))` da listÄ™ krotek.

---

## 3) List Comprehension â€” szybko twÃ³rz listy
```{python}
#| classes: thebe
nums = [1, 2, 3, 4, 5]
squares_even = [x*x for x in nums if x % 2 == 0]
squares_even
```

---

### Mini-zadanie âœ…
Wygeneruj listÄ™ **dÅ‚ugoÅ›ci** kaÅ¼dego napisu w `fruits`, ale **tylko** dla owocÃ³w o nazwie dÅ‚uÅ¼szej niÅ¼ 5 znakÃ³w.

```{python}
#| classes: thebe
# TODO: uzupeÅ‚nij list comprehension
fruits = ["apple", "banana", "cherry", "kiwi"]
# lengths = [...]
# lengths
```

---

## 4) Dictionary Comprehension â€” buduj sÅ‚owniki efektywnie
```{python}
#| classes: thebe
products = ["laptop", "mouse", "keyboard", "monitor"]
prices = [2999, 59, 199, 899]
product_dict = {product: price for product, price in zip(products, prices) if price < 1000}
product_dict
```

**Protip:** MoÅ¼esz teÅ¼ tworzyÄ‡ sÅ‚owniki z warunkami: `{k: v for k, v in items if condition}`.

---

## 5) f-strings â€” formatuj stringi czytelnie
```{python}
#| classes: thebe
name = "Anna"
age = 25
score = 95.567
# Stary sposÃ³b
print("Nazywam siÄ™ " + name + ", mam " + str(age) + " lat")
# f-string way ğŸš€
print(f"Nazywam siÄ™ {name}, mam {age} lat i mÃ³j wynik to {score:.2f}")
```

**Dlaczego warto:** Czytelniejsze i szybsze niÅ¼ `.format()` czy konkatenacja.

---

## 6) `collections.Counter` â€” licz elementy automatycznie
```{python}
#| classes: thebe
from collections import Counter
grades = ["A", "B", "A", "C", "B", "A", "B", "C", "A"]
grade_counts = Counter(grades)
print(grade_counts)
print(f"NajczÄ™stsza ocena: {grade_counts.most_common(1)[0][0]}")
```

**Data Science tip:** Idealne do analizy czÄ™stoÅ›ci kategorii w danych!

---

## 7) `*args` i `**kwargs` â€” elastyczne funkcje
```{python}
#| classes: thebe
def smart_print(*args, **kwargs):
    separator = kwargs.get('sep', ' | ')
    prefix = kwargs.get('prefix', '>>> ')
    print(prefix + separator.join(str(arg) for arg in args))

# RÃ³Å¼ne sposoby wywoÅ‚ania
smart_print("Python", "jest", "super")
smart_print("A", "B", "C", sep=" -> ", prefix="WYNIK: ")
smart_print(1, 2, 3, 4, 5, sep=", ")
```

**Dlaczego warto:** Funkcje mogÄ… przyjmowaÄ‡ dowolnÄ… liczbÄ™ argumentÃ³w pozycyjnych (`*args`) i nazwanych (`**kwargs`).

---

## 8) `defaultdict` â€” sÅ‚owniki z domyÅ›lnymi wartoÅ›ciami
```{python}
#| classes: thebe
from collections import defaultdict

# Standardowy sÅ‚ownik - trzeba sprawdzaÄ‡ klucze
normal_dict = {}
# if 'python' not in normal_dict:
#     normal_dict['python'] = []
# normal_dict['python'].append('awesome')

# defaultdict - automatyczne wartoÅ›ci domyÅ›lne
courses = defaultdict(list)
courses['python'].append('basics')
courses['python'].append('advanced')
courses['javascript'].append('react')

print(dict(courses))  # Konwersja do normalnego dict dla czytelnoÅ›ci
```

**Protip:** `defaultdict(int)` dla licznikÃ³w, `defaultdict(list)` dla grup, `defaultdict(set)` dla unikalnych wartoÅ›ci.

---

## 9) `any()` i `all()` â€” sprawdzaj warunki w kolekcjach
```{python}
#| classes: thebe
numbers = [2, 4, 6, 8, 10]
mixed_numbers = [1, 2, 3, 4, 5]
empty_list = []

# Czy wszystkie elementy sÄ… parzyste?
print(f"Wszystkie parzyste w {numbers}: {all(n % 2 == 0 for n in numbers)}")
print(f"Wszystkie parzyste w {mixed_numbers}: {all(n % 2 == 0 for n in mixed_numbers)}")

# Czy ktÃ³rykolwiek element jest wiÄ™kszy niÅ¼ 5?
print(f"JakiÅ› > 5 w {numbers}: {any(n > 5 for n in numbers)}")
print(f"JakiÅ› > 5 w {mixed_numbers}: {any(n > 5 for n in mixed_numbers)}")

# Edge case - pusta lista
print(f"all([]) = {all(empty_list)}")  # True (bo nie ma elementÃ³w faÅ‚szywych)
print(f"any([]) = {any(empty_list)}")  # False (bo nie ma elementÃ³w prawdziwych)
```

**Data Science tip:** Åšwietne do walidacji danych - `all(df['age'] > 0)` sprawdzi czy kaÅ¼dy wiek jest dodatni!

---

### Finalne wyzwanie ğŸ†
StwÃ³rz funkcjÄ™ `analyze_grades(grades_list)`, ktÃ³ra:

1. Przyjmuje listÄ™ ocen (stringi: "A", "B", "C", "D", "F")
2. Zwraca sÅ‚ownik z informacjami:
   - `counts`: liczba kaÅ¼dej oceny (uÅ¼yj `Counter`)
   - `has_failing`: czy sÄ… oceny F (uÅ¼yj `any()`)
   - `all_passing`: czy wszystkie oceny to A-D (uÅ¼yj `all()`)
   - `top_grade`: najczÄ™stsza ocena

```{python}
#| classes: thebe
from collections import Counter

def analyze_grades(grades_list):
    # TODO: UzupeÅ‚nij funkcjÄ™
    # counts = ...
    # has_failing = ...
    # all_passing = ...
    # top_grade = ...
    # return {...}
    pass

# Test
test_grades = ["A", "B", "A", "C", "B", "A", "D", "C", "A"]
# result = analyze_grades(test_grades)
# print(result)
```