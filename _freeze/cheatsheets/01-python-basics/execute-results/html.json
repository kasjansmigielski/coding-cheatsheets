{
  "hash": "3fe5392468646a414dfae83c16cb6569",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python Basics ‚Äî 9 protip√≥w\"\nformat:\n  html:\n    code-tools: true\n---\n\n## 1) `enumerate` ‚Äî numeruj elementy w pƒôtli\n\n::: {#78b30532 .cell .thebe execution_count=1}\n``` {.python .cell-code}\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor i, f in enumerate(fruits, start=1):\n    print(i, f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 apple\n2 banana\n3 cherry\n```\n:::\n:::\n\n\n**Dlaczego warto:** zamiast rƒôcznie liczyƒá indeksy.\n\n---\n\n## 2) `zip` ‚Äî paruj listy w locie\n\n::: {#0574730b .cell .thebe execution_count=2}\n``` {.python .cell-code}\nnames = [\"Ala\", \"Bartek\", \"Cezary\"]\nscores = [84, 92, 78]\nfor name, score in zip(names, scores):\n    print(f\"{name}: {score}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAla: 84\nBartek: 92\nCezary: 78\n```\n:::\n:::\n\n\n**Protip:** `list(zip(names, scores))` da listƒô krotek.\n\n---\n\n## 3) List Comprehension ‚Äî szybko tw√≥rz listy\n\n::: {#ea2dfbe2 .cell .thebe execution_count=3}\n``` {.python .cell-code}\nnums = [1, 2, 3, 4, 5]\nsquares_even = [x*x for x in nums if x % 2 == 0]\nsquares_even\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n[4, 16]\n```\n:::\n:::\n\n\n---\n\n### Mini-zadanie ‚úÖ\nWygeneruj listƒô **d≈Çugo≈õci** ka≈ºdego napisu w `fruits`, ale **tylko** dla owoc√≥w o nazwie d≈Çu≈ºszej ni≈º 5 znak√≥w.\n\n::: {#cf6c72b4 .cell .thebe execution_count=4}\n``` {.python .cell-code}\n# TODO: uzupe≈Çnij list comprehension\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\"]\n# lengths = [...]\n# lengths\n```\n:::\n\n\n---\n\n## 4) Dictionary Comprehension ‚Äî buduj s≈Çowniki efektywnie\n\n::: {#a0103d73 .cell .thebe execution_count=5}\n``` {.python .cell-code}\nproducts = [\"laptop\", \"mouse\", \"keyboard\", \"monitor\"]\nprices = [2999, 59, 199, 899]\nproduct_dict = {product: price for product, price in zip(products, prices) if price < 1000}\nproduct_dict\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n{'mouse': 59, 'keyboard': 199, 'monitor': 899}\n```\n:::\n:::\n\n\n**Protip:** Mo≈ºesz te≈º tworzyƒá s≈Çowniki z warunkami: `{k: v for k, v in items if condition}`.\n\n---\n\n## 5) f-strings ‚Äî formatuj stringi czytelnie\n\n::: {#03fe04a0 .cell .thebe execution_count=6}\n``` {.python .cell-code}\nname = \"Anna\"\nage = 25\nscore = 95.567\n# Stary spos√≥b\nprint(\"Nazywam siƒô \" + name + \", mam \" + str(age) + \" lat\")\n# f-string way üöÄ\nprint(f\"Nazywam siƒô {name}, mam {age} lat i m√≥j wynik to {score:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNazywam siƒô Anna, mam 25 lat\nNazywam siƒô Anna, mam 25 lat i m√≥j wynik to 95.57\n```\n:::\n:::\n\n\n**Dlaczego warto:** Czytelniejsze i szybsze ni≈º `.format()` czy konkatenacja.\n\n---\n\n## 6) `collections.Counter` ‚Äî licz elementy automatycznie\n\n::: {#dc9ef0dd .cell .thebe execution_count=7}\n``` {.python .cell-code}\nfrom collections import Counter\ngrades = [\"A\", \"B\", \"A\", \"C\", \"B\", \"A\", \"B\", \"C\", \"A\"]\ngrade_counts = Counter(grades)\nprint(grade_counts)\nprint(f\"Najczƒôstsza ocena: {grade_counts.most_common(1)[0][0]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCounter({'A': 4, 'B': 3, 'C': 2})\nNajczƒôstsza ocena: A\n```\n:::\n:::\n\n\n**Data Science tip:** Idealne do analizy czƒôsto≈õci kategorii w danych!\n\n---\n\n## 7) `*args` i `**kwargs` ‚Äî elastyczne funkcje\n\n::: {#3ecc2f82 .cell .thebe execution_count=8}\n``` {.python .cell-code}\ndef smart_print(*args, **kwargs):\n    separator = kwargs.get('sep', ' | ')\n    prefix = kwargs.get('prefix', '>>> ')\n    print(prefix + separator.join(str(arg) for arg in args))\n\n# R√≥≈ºne sposoby wywo≈Çania\nsmart_print(\"Python\", \"jest\", \"super\")\nsmart_print(\"A\", \"B\", \"C\", sep=\" -> \", prefix=\"WYNIK: \")\nsmart_print(1, 2, 3, 4, 5, sep=\", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n>>> Python | jest | super\nWYNIK: A -> B -> C\n>>> 1, 2, 3, 4, 5\n```\n:::\n:::\n\n\n**Dlaczego warto:** Funkcje mogƒÖ przyjmowaƒá dowolnƒÖ liczbƒô argument√≥w pozycyjnych (`*args`) i nazwanych (`**kwargs`).\n\n---\n\n## 8) `defaultdict` ‚Äî s≈Çowniki z domy≈õlnymi warto≈õciami\n\n::: {#a55d3ed9 .cell .thebe execution_count=9}\n``` {.python .cell-code}\nfrom collections import defaultdict\n\n# Standardowy s≈Çownik - trzeba sprawdzaƒá klucze\nnormal_dict = {}\n# if 'python' not in normal_dict:\n#     normal_dict['python'] = []\n# normal_dict['python'].append('awesome')\n\n# defaultdict - automatyczne warto≈õci domy≈õlne\ncourses = defaultdict(list)\ncourses['python'].append('basics')\ncourses['python'].append('advanced')\ncourses['javascript'].append('react')\n\nprint(dict(courses))  # Konwersja do normalnego dict dla czytelno≈õci\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'python': ['basics', 'advanced'], 'javascript': ['react']}\n```\n:::\n:::\n\n\n**Protip:** `defaultdict(int)` dla licznik√≥w, `defaultdict(list)` dla grup, `defaultdict(set)` dla unikalnych warto≈õci.\n\n---\n\n## 9) `any()` i `all()` ‚Äî sprawdzaj warunki w kolekcjach\n\n::: {#6eb3b296 .cell .thebe execution_count=10}\n``` {.python .cell-code}\nnumbers = [2, 4, 6, 8, 10]\nmixed_numbers = [1, 2, 3, 4, 5]\nempty_list = []\n\n# Czy wszystkie elementy sƒÖ parzyste?\nprint(f\"Wszystkie parzyste w {numbers}: {all(n % 2 == 0 for n in numbers)}\")\nprint(f\"Wszystkie parzyste w {mixed_numbers}: {all(n % 2 == 0 for n in mixed_numbers)}\")\n\n# Czy kt√≥rykolwiek element jest wiƒôkszy ni≈º 5?\nprint(f\"Jaki≈õ > 5 w {numbers}: {any(n > 5 for n in numbers)}\")\nprint(f\"Jaki≈õ > 5 w {mixed_numbers}: {any(n > 5 for n in mixed_numbers)}\")\n\n# Edge case - pusta lista\nprint(f\"all([]) = {all(empty_list)}\")  # True (bo nie ma element√≥w fa≈Çszywych)\nprint(f\"any([]) = {any(empty_list)}\")  # False (bo nie ma element√≥w prawdziwych)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWszystkie parzyste w [2, 4, 6, 8, 10]: True\nWszystkie parzyste w [1, 2, 3, 4, 5]: False\nJaki≈õ > 5 w [2, 4, 6, 8, 10]: True\nJaki≈õ > 5 w [1, 2, 3, 4, 5]: False\nall([]) = True\nany([]) = False\n```\n:::\n:::\n\n\n**Data Science tip:** ≈öwietne do walidacji danych - `all(df['age'] > 0)` sprawdzi czy ka≈ºdy wiek jest dodatni!\n\n---\n\n### Finalne wyzwanie üèÜ\nStw√≥rz funkcjƒô `analyze_grades(grades_list)`, kt√≥ra:\n\n1. Przyjmuje listƒô ocen (stringi: \"A\", \"B\", \"C\", \"D\", \"F\")\n2. Zwraca s≈Çownik z informacjami:\n   - `counts`: liczba ka≈ºdej oceny (u≈ºyj `Counter`)\n   - `has_failing`: czy sƒÖ oceny F (u≈ºyj `any()`)\n   - `all_passing`: czy wszystkie oceny to A-D (u≈ºyj `all()`)\n   - `top_grade`: najczƒôstsza ocena\n\n::: {#3bc74c21 .cell .thebe execution_count=11}\n``` {.python .cell-code}\nfrom collections import Counter\n\ndef analyze_grades(grades_list):\n    # TODO: Uzupe≈Çnij funkcjƒô\n    # counts = ...\n    # has_failing = ...\n    # all_passing = ...\n    # top_grade = ...\n    # return {...}\n    pass\n\n# Test\ntest_grades = [\"A\", \"B\", \"A\", \"C\", \"B\", \"A\", \"D\", \"C\", \"A\"]\n# result = analyze_grades(test_grades)\n# print(result)\n```\n:::\n\n\n",
    "supporting": [
      "01-python-basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}